---
title: "US Weather Effects on Population Health and the Economic Consequences 2001 - 2011"
output: html_document
---

## Synopsis
In this report we aim to describe which type of US weather events are most
harmful with respect to **population health** (injuries and fatalities) and which
have the greatest **economic consequences** (property and crop damage).

This report explores the NOAA Storm Database, calculating the average consequences
over a period of time.
Although the NOAA Storm Database contains records from
1950 - November 2011, we confirm that earlier years have fewer events recorded.
We decide to use the time period of the **last 10 years**, which matches the
interval used by National Weather Service - [Natural Hazard Statistics]
(http://www.nws.noaa.gov/om/hazstats.shtml).

This report shows that **tornadoes** have the worst total effect on popluation health
while **dought** has the greatest economic consequences during this period.

--------------------------------------------------------------------------------

## Data Processing
The following R libraries are used.
```{r}
library(assertthat)
library(stringr)
library(dplyr)
library(ggplot2)
```

### Reading in the data
We first read in the data from the csv file in
[Storm Data](https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2)
47mb bzip2 file.
The data is a bzip2 compressed, comma separated file containing a header and
missing values are coded as blank fields.
```{r noaa-severe-weather-read, cache=TRUE}
storms.orig <- read.csv("data/repdata-data-StormData.csv.bz2", header=TRUE,
                        na.strings="", stringsAsFactors=FALSE)
```

After reading the data into `storms.orig` we see that there are
`r nrow(storms.orig)` observations (rows) and 
`r ncol(storms.orig)` variables (columns) in this dataset.
```{r}
dim(storms.orig)
```

#### Exploring the data
We explore the first few rows in this dataset.  These documents help us find how some of the variables are constructed/defined.

  - National Weather Service [Storm Data Documentation](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf)
  - National Climatic Data Center Storm Events [FAQ](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2FNCDC%20Storm%20Events-FAQ%20Page.pdf)

```{r}
head(storms.orig)
```

The `EVTYPE` event type variable will be needed to determine the weather event.
The `BGN_DATE` variable will be used to filter weather events by year.
Additionally, the following variables contain data useful for this report.

  - To determine population health, the following variables are needed:
    - `FATALITIES` - The number of direct or indirect fatalities attributable to the event.
    - `INJURIES` - The number of direct or indirect injuries attributable to the event.
  - Economic consequences:
    - `PROPDMG` - Property damage dollar amount
    - `PROPDMGEXP` - Property damage dollar amount magnitude (K, M, B, etc.)
    - `CROPDMG` - Crop damage dollar amount
    - `CROPDMGEXP` - Crop damage dollar amount magnitude (K, M, B, etc.)

#### Subsetting by dataset variables
Reducing the dataset to only those variables we are focusing on both helps
pre-eliminate non-essential values that we would have to otherwise visually
inspect later in the analysis and also improves subsequent computational performance.

`storms.df` will contain the reduced, cleaned, and tidied dataset used
throughout the remainder of the report.
```{r}
storms.df <- select(storms.orig,
                    EVTYPE, BGN_DATE, FATALITIES, INJURIES,
                    PROPDMG, PROPDMGEXP, CROPDMG, CROPDMGEXP)
dim(storms.df)
```
The number of variables used decreases from `r ncol(storms.orig)`
to `r ncol(storms.df)`.

#### Subsetting by Year
The following histogram supports the claim that the earlier years of the database have generally fewer event records, most likely due to a lack of good records.
```{r}
storms.df <- mutate(storms.df, bgn_year=as.integer(format(strptime(storms.df$BGN_DATE, "%m/%d/%Y"), "%Y")))
max_year <- max(storms.df$bgn_year)
min_year <- max(min(storms.df$bgn_year), max_year - 10)
unique(storms.df$bgn_year)
```
```{r}
ggplot(storms.df, aes(x=bgn_year, fill=bgn_year >= min_year)) +
    ggtitle(paste("Number of Weather Event Observations per Year")) +
    xlab("Year\nfigure 1.") + ylab("Number Events") +
    theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1)) +
    scale_fill_manual("Used in\nthis report", values=c("white", "red")) +
    geom_histogram(binwidth=1, color="black")
```

It looks like more records were kept from 1995 onwards.
We decide to use the time period of the **last 10 years**, which matches
the interval used by National Weather Service - [Natural Hazard Statistics]
(http://www.nws.noaa.gov/om/hazstats.shtml).
Although 2011 only has records through November, we include 2011
nonetheless as it has the most number of records for a year.
`storms.df` is then subsetted accordingly.
```{r}
storms.df <- filter(storms.df, bgn_year >= min_year)
dim(storms.df)
```

#### Filtering the dataset
Reducing the dataset to only those observations where there are injures/fatalities
or property/crop damage also helps.
```{r}
storms.df <- filter(storms.df, FATALITIES>0 | INJURIES>0 | PROPDMG>0 | CROPDMG>0)
dim(storms.df)
```

The number of observations used decreases from `r nrow(storms.orig)`
to `r nrow(storms.df)`.

#### Tidying Event Types
The previous subsetting and filter results in `r length(unique(storms.df$EVTYPE))`
unique `EVTYPE` values we need to consider in the reduced `storms.df` dataset
versus the original `r length(unique(storms.orig$EVTYPE))` values in `storms.orig`.
```{r}
unique(storms.df$EVTYPE)
```

Still, there are many event types.  Through visual inspection, we'll now attempt
to somewhat normalize them while retaining a reasonable level of fidelity.
The code below shows the series of transformations used.
```{r}
normalizedEVTYPE <- storms.df$EVTYPE

# Upper case all
normalizedEVTYPE <- toupper(normalizedEVTYPE)

# Replace special characters /, (, ), ., \, &, - with space
normalizedEVTYPE <- gsub("/|\\(|\\)|\\.|\\\\|\\&|\\-", " ", normalizedEVTYPE)

# Remove numeric F, G, or numeric magnitudes
normalizedEVTYPE <- gsub("[F|G]\\d+", " ", normalizedEVTYPE)
normalizedEVTYPE <- gsub("\\d+", " ", normalizedEVTYPE)

# Remove plurality
normalizedEVTYPE <- gsub("RAINS\\s", "RAIN ", normalizedEVTYPE)
normalizedEVTYPE <- gsub("STORMS", "STORM", normalizedEVTYPE)
normalizedEVTYPE <- gsub("WINDS", "WIND", normalizedEVTYPE)
normalizedEVTYPE <- gsub("FLOODS", "FLOOD", normalizedEVTYPE)

# Remove adjectives
normalizedEVTYPE <- gsub("HARD |HIGH |SEVERE |HEAVY |EXCESSIVE |STRONG | INJURY", " ", normalizedEVTYPE)

# Any tornado becomes tornado
normalizedEVTYPE <- gsub("TORNADOES|TORNDAO", "TORNADO", normalizedEVTYPE)
normalizedEVTYPE <- gsub(".*TORNADO.*", "TORNADO", normalizedEVTYPE)

# Any hurricane becomes hurricane
normalizedEVTYPE <- gsub(".*HURRICANE.*", "HURRICANE", normalizedEVTYPE)

# Any thunderstorm becomes thunderstorm
normalizedEVTYPE <- gsub("TSTM|THUNERSTORM|TUNDERSTORM|THUDERSTORM|THUNDERTORM|THUNDEERSTORM", "THUNDERSTORM", normalizedEVTYPE)
normalizedEVTYPE <- gsub(".*THUNDERSTORM.*", "THUNDERSTORM", normalizedEVTYPE)

# Snow
normalizedEVTYPE <- gsub("SNOWFALL", "SNOW", normalizedEVTYPE)

# Trim adjacent whitespace
normalizedEVTYPE <- gsub("\\s+", " ", normalizedEVTYPE)

# Trim leading and trailing blanks
normalizedEVTYPE <- str_trim(normalizedEVTYPE)

storms.df$normalizedEVTYPE <- normalizedEVTYPE
```

The number of unique types has been reduced from the
original `r length(unique(storms.orig$EVTYPE))`
to `r length(unique(normalizedEVTYPE))`.
```{r}
unique(normalizedEVTYPE)
```

#### Miscellaneous Tidying


--------------------------------------------------------------------------------

## Results

### Injuries and Fatalities
Copy and filter the reduced `storms.df` dataset to only those observations where
there is an injury or fatality and store it in `human.df`.
```{r}
human.df <- storms.df[storms.df$FATALITIES>0 | storms.df$INJURIES>0, ]
```

Summarize the injuries and fatalities by event type and store it in `human.summary`.
```{r}
human.summary <- human.df %>% group_by(normalizedEVTYPE) %>%
    summarise(souls=sum(INJURIES, FATALITIES))
dim(human.summary)
```

There are an average of *`r as.character(sum(human.summary$souls))`* injuries and fatalities.
There are *`r nrow(human.summary)`* different normalized event types;
Since this report focuses on the events with the worst impacts, and not all,
I've decided to only look at the **top `r top_n <- 20` `r top_n`** for this report.
```{r}
human.top_summary <- top_n(human.summary, top_n, souls)
arrange(human.top_summary, desc(souls))
```

Plot `human.top_summary` and notice the event with the worst impact.
```{r}
# Find event with worst impact
index <- which.max(human.top_summary$souls)
evtype <- human.top_summary$normalizedEVTYPE[index]
cnt <- human.top_summary$souls[index]

# Plot
ggplot(human.top_summary, aes(x=normalizedEVTYPE, y=souls)) +
  ggtitle(paste("Top", top_n, "Injuries and Fatalities per Event Type\n",
                min_year, " - ", max_year)) +
  xlab("Event Type\nfigure 2.") + ylab("Count") +
  theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1)) +
  geom_point() +
  geom_text(hjust=0, yjust=0, size=4, color="red",
            aes(label=paste(evtype, cnt),
                x=human.top_summary$normalizedEVTYPE[index], y=cnt))
```


### Property and Crop Damage
Copy and filter the reduced `storms.df` dataset to only those observations where
there is property or crop damage and store it in `damage.df`.
```{r}
damage.df <- storms.df[storms.df$PROPDMG>0 | storms.df$CROPDMG>0, ]
dim(damage.df)
head(damage.df)
```

Before we can create a table that summarizes the damage costs, we need to compute
normalized costs from `damage.df$PROPDMG`/`damage.df$PROPDMGEXP` and
`damage.df$CROPDMG`/`damage.df$CROPDMGEXP`.
Some of the EXP units are in lower case, so upper case them all.
```{r}
damage.df$PROPDMGEXP <- toupper(damage.df$PROPDMGEXP)
damage.df$CROPDMGEXP <- toupper(damage.df$CROPDMGEXP)
unique(damage.df$PROPDMGEXP)
unique(damage.df$CROPDMGEXP)
```

The code below computes each observation's total cost in units of thousands
of dollars in a new `kcost` variable.
Per page section 2.7 of [Storm Data Documentation](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf), K = thousands, M = millions,
and B = billions.
In prior years there were also rogue EXP units some of which were numeric
(treated as base 10 exponents).  
I've decided to treat all others as K since that's the smallest EXP unit from section 2.7.
```{r}
damage.df <- mutate(damage.df, kcost=0)
for (i in 1:nrow(damage.df)) {
  row <- damage.df[i,]
  kcost <- 0
  
  # Include property damage in kcost
  kdmg <- row["PROPDMG"]
  if (kdmg > 0) {
    exp <- row["PROPDMGEXP"]
    if (!is.na(exp)) {
      if        (exp=="3"|exp=="K") { k <- kdmg
      } else if (exp=="4")          { k <- kdmg * 10
      } else if (exp=="5")          { k <- kdmg * 100
      } else if (exp=="6"|exp=="M") { k <- kdmg * 1000
      } else if (exp=="7")          { k <- kdmg * 10000
      } else if (exp=="B")          { k <- kdmg * 1000000
      } else                        { k <- kdmg # Assume thousands
        print(row)
      }
    }
  }

  kdmg <- row["CROPDMG"]
  if (kdmg > 0) {
    exp <- row["CROPDMGEXP"]
    if (!is.na(exp)) {
      if        (exp=="3"|exp=="K") { k <- kdmg
      } else if (exp=="4")          { k <- kdmg * 10
      } else if (exp=="5")          { k <- kdmg * 100
      } else if (exp=="6"|exp=="M") { k <- kdmg * 1000
      } else if (exp=="7")          { k <- kdmg * 10000
      } else if (exp=="B")          { k <- kdmg * 1000000
      } else                        { k <- kdmg # Assume thousands
        print(row)
      }
      kcost <- kcost + k
    }
  }
  
  damage.df[i, "kcost"] <- kcost
}
```

Summarize the property and crop damage by event type and store it in `damage.summary`.
```{r}
damage.summary <- damage.df %>% group_by(normalizedEVTYPE) %>% summarise(kcost=sum(kcost))
```
There are a total of *`r as.character(sum(damage.summary$kcost))`* USD property and
crop damage costs.
There are *`r nrow(damage.summary)`* different normalized event types;
Since this report focuses on the events with the worst impacts, and not all,
I've decided to only look at the *top `r top_n <- 20` `r top_n`* for this report.
```{r}
damage.top_summary <- top_n(damage.summary, top_n, kcost)
arrange(damage.top_summary, desc(kcost))
```

Plot `damage.top_summary` and notice the event with the worst impact.
```{r}
# Find event with worst impact
index <- which.max(damage.top_summary$kcost)
evtype <- damage.top_summary$normalizedEVTYPE[index]
cnt <- damage.top_summary$kcost[index]

# Plot
ggplot(damage.top_summary, aes(x=normalizedEVTYPE, y=kcost)) +
  ggtitle(paste("Top", top_n, "Property and Crop Damage per Event Type\n",
                min_year, " - ", max_year)) +
  xlab("Event Type\nfigure 3.") + ylab("Cost (Thousand $)") +
  theme(axis.text.x=element_text(angle=45, vjust=1, hjust=1)) +
  geom_point() +
  geom_text(hjust=0, yjust=0, size=4, color="red",
            aes(label=paste(evtype, cnt),
                x=damage.top_summary$normalizedEVTYPE[index], y=cnt))
```
